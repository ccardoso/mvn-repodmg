package healthy.rim.type;import java.sql.Timestamp;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Locale;import java.util.TimeZone;import java.util.logging.Level;import java.util.logging.Logger;import javax.xml.bind.annotation.XmlAccessType;import javax.xml.bind.annotation.XmlAccessorType;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;import javax.xml.bind.annotation.XmlType;import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;/** * TS it's a wrapper around * <code>java.util.Date</code> that allows the JDBC API to identify this as an * SQL * <code>TIMESTAMP</code> value. * * @author Yosvany Llerena Rodr√≠guez <yosvanyllr@gmail.com> * @since 23-Jan-2013 */ @XmlRootElement(name = "TS")@XmlAccessorType(XmlAccessType.FIELD)@XmlType(name = "TS")public class TS extends RimDataType {    private static final SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd hh:mm:ss.SSS");    @XmlElement(name = "time", required = true)    @XmlJavaTypeAdapter(TimestampAdapter.class)    private Date time = new Date();    public TS() {        final Calendar calendar = new GregorianCalendar(TimeZone.getDefault(), Locale.ENGLISH);        this.time = new Date(calendar.getTimeInMillis());    }    public TS(Date time) {        this.time = time;    }    public TS(Timestamp time) {        this.time = new Date(time.getTime());    }    public TS(String time) {        try {            this.time = new Date(formatter.parse(time).getTime());        } catch (ParseException ex) {            Logger.getLogger(TS.class.getName()).log(Level.SEVERE, null, ex);        }    }    public Date getTime() {        return time;    }    public void setTime(Date time) {        this.time = time;    }    /**     * More than comparison     *     * @return Return true current date is bigger else return false     */    public boolean isMore(Date dtime) {        if (isEqual(dtime)) {            return false;        } else {            return (this.time.getTime() > dtime.getTime());        }    }    /**     * Equal comparison     *     * @return Return true current date is equal else return false     */    public boolean isEqual(Date dtime) {        return (this.time.getTime() == dtime.getTime());    }    /**     * MLess than comparison     *     * @return Return true current date is little else return false     */    public boolean isLess(Date dtime) {        if (isEqual(dtime)) {            return false;        } else {            return (this.time.getTime() < dtime.getTime());        }    }    @Override    public String toString() {        return formatter.format(time);    }    @Override    public int hashCode() {        int hash = 7;        hash = 47 * hash + (this.time != null ? this.time.hashCode() : 0);        return hash;    }    @Override    public boolean equals(Object obj) {        if (obj == null) {            return false;        }        if (getClass() != obj.getClass()) {            return false;        }        final TS other = (TS) obj;        if (this.time != other.time && (this.time == null || !this.time.equals(other.time))) {            return false;        }        return true;    }}